object oriented programming

classes & objects:
1. objects are entities on the real world.
2. class is like a blueprint of these entities.
3. by default all properties & methods are private inside the class.

access modifiers:
1. private: data & methods accessible inside the class.
2. public: data & methods accessible to everyone.
3. protected: data & methods accessible inside class & to its derived class.

oops have 4 pillars:
1. Encapsulation
2. Abstruction
3. Inheritence
4. Polymorphism

1. Encalsulation: if we take some properties and methods under class then these properties and methods will combinely called encapsulation.
Example:

class Teacher {
private:
    // now the salary is private
    double salary;

public:
    // properties/ attributes
    string name;
    string dept;
    string subject;

    // methods/ member function
    void changedept(string newdept){
        dept = newdept;
    }

    // setter(sets the values of private property)
    void setSalary(double s){
        salary = s;
    }

    //getter(returns the values of private property)
    double getSalary(){
        return salary;
    }
};

Constructor: special methods invoked autometically at the time of object creation. used for initialisation.

key points:

same name as class(i.e if we decleare the class name as "class Teacher" the constructor name will be Teacher).

constructor doesn't have a reutrn type.

only called once(autometically) at object creation.

memory allocation happens when constructor is called(constructor doesn't created for classes it created for objects. when a class is created few amount of memory will be allocated but when an object is created the memory allocation will be happened and the memory will be allocated for  objects when the constructor is called. it can be called by default with compiler constructor or with user defined constructor).

constructor should be must called inside public access modifier. 


constructor will be called at first for each object declearation.

contructor overloading(when multiple constructors are available inside a single class) is a example of polymorphisom.

Contructor will be called for each object everytime at first.

Example:

#include <iostream>
#include <string>
using namespace std;
class Teacher {

// sometimes called data hiding
private:
    // now the salary is private
    double salary;

public:
    // properties/ attributes
    string name;
    string dept;
    string subject;

    // constructor(this line will print at frist and will be printed for 2 times because here is 2 objects t1 & t2)
    /* output: hi, i am costructor
               hi, i am costructor
               mahir
               23000
               akib */ 
    Teacher(){
        cout << "hi, i am costructor" << endl;
    }

    // methods/ member function
    void changedept(string newdept){
        dept = newdept;
    }

    // setter(sets the values of private property)
    void setSalary(double s){
        salary = s;
    }

    //getter(returns the values of private property)
    double getSalary(){
        return salary;
    }
};

int main(){
    Teacher t1, t2;// constructor called autometically
    t1.name = "mahir";
    t2.name = "akib";
    t1.setSalary(23000);

    cout << t1.name << endl;
    cout << t1.getSalary() << endl;
    cout << t2.name << endl;
    return 0;
} 


there are three types of constructor:
1. unperameterized constructor

Example:

Teacher(){
        cout << "hi, i am costructor" << endl;
    }

2. perameterized constructor

Example:

Teacher(string n, string d, string s, double sal){
        name = n;
        dept = d;
        subject = s;
        salary = sal;
    }

3. copy constructor: special constructor (default) used to copy properties of one object to another.

there are two types of copy constructor:
1. default copy costructor 

Example:

#include <iostream>
#include <string>
using namespace std;
class Teacher {
private:
    double salary;
public:
    string name;
    string dept;
    string subject;

    Teacher(string name, string dept, string subject, double salary){
        this->name = name;
        this->dept = dept;
        this->subject = subject;
        this->salary = salary;
    }
    void getinfo(){
        cout << "name: " << name << endl;
        cout << "subject: " << subject << endl;
    }
};
int main(){
    Teacher t1("mahir", "cse", "c++", 25000);
    Teacher t2(t1); // default copy constructor
    t2.getinfo();
}

2. custom or user defined copy constructor

Example:

#include <iostream>
#include <string>
using namespace std;
class Teacher {
private:
    double salary;
public:
    string name;
    string dept;
    string subject;

    Teacher(string name, string dept, string subject, double salary){
        this->name = name;
        this->dept = dept;
        this->subject = subject;
        this->salary = salary;
    }

    // custom copy constructor
    Teacher(Teacher &originalObject){
        this->name = originalObject.name;
        this->dept = originalObject.dept;
        this->subject = originalObject.subject;
        this->salary = originalObject.salary;
    }

    void getinfo(){
        cout << "name: " << name << endl;
        cout << "subject: " << subject << endl;
    }
};
int main(){
    Teacher t1("mahir", "cse", "c++", 25000);
    Teacher t2(t1); // custom copy constructor
    t2.getinfo();
}

"this" is a special pointer in c++ that points to the current object. when a new object is created this pointer points to that object. this->property is same as *(this).property.

Shallow copy constructor: a shallow copy of an object copies all of the member values from one object ot another. but it creates problem when the memory is dynamically allocated. compiler can create shallow constructor by default.

Example:

#include <iostream>
#include <string>
using namespace std;

class Student {
public:
    string name;
    double* cgpaptr;

    Student(string name, double cgpa) {
        this->name = name;
        cgpaptr = new double;
        *cgpaptr = cgpa;
    }

    // shallow copy
    Student(Student &originalObject) {
        this->name = originalObject.name;
        this->cgpaptr = originalObject.cgpaptr;
    }

    void getInfo() {
        cout << "name: " << name << endl;
        cout << "cgpa: " << *cgpaptr << endl;
    }
};
int main() {
    Student s1("mahir", 4.0);
    s1.getInfo(); // cgpa will 4.0 for s1
    Student s2(s1);
    *(s2.cgpaptr) = 3.5;
    s1.getInfo(); // cgpa will 3.5 for s1

    /* here the problem is in dynamic memory allocation when we change the cgpa of s2, the s1 cgpa has been autometically changed because of shallow constructor and this is the problem of shallow constructor during dynamic memory allocation */
}

Deep copy constructor: a deep copy constructor not only copies the member values but also makes copies of any dynamically allocated memory that the members points to. compiler cannot create deep copy constructor by default, it should be created by user.

Example:

#include <iostream>
#include <string>
using namespace std;

class Student {
public:
    string name;
    double* cgpaptr;

    Student(string name, double cgpa) {
        this->name = name;
        cgpaptr = new double;
        *cgpaptr = cgpa;
    }

    // deep copy
    Student(Student &originalObject) {
        this->name = originalObject.name;
        this->cgpaptr = new double;
        *cgpaptr = *(originalObject.cgpaptr); // just copying the value
    }

    void getInfo() {
        cout << "name: " << name << endl;
        cout << "cgpa: " << *cgpaptr << endl;
    }
};

int main() {
    Student s1("mahir", 4.0);
    s1.getInfo(); 
    Student s2(s1);
    *(s2.cgpaptr) = 3.5;
    s1.getInfo(); 
    s2.getInfo();
}


Destructor: destructor is opposite to constructor. constructor is mainly works for allocating memory for new created object on the other side destructor de-allocates memory. dectructor is autometically created by compiler. for example, when a program terminated the objects are autometically deleted (it's for static memory allocation not for dynamic memory allocation). destructor has the same name as class.

Example:

// destructor
    ~Student() {
        cout << "hi i am destructor" << endl;
        delete cgpaptr;
    }




2. Inheritance: when properties and members functions of base class (parent class) are passed on to the derived class (child class). in terms of constructor calling, parent class constructor is called then child constructor is called. again, in terms of destructor, the child class memory will be deallocated first then the parent class memory will be deallocated. destructor works opposite of constructor in Inheritance.
       
       if the parent class is in private mode it cannot be possible to inherit those property in child class.
       if the parent is in protected mode, the properties of parent class can only be inherit.

     
